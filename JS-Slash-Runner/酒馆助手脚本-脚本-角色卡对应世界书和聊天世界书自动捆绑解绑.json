{
  "type": "script",
  "enabled": true,
  "name": "脚本-角色卡对应世界书和聊天世界书自动捆绑解绑",
  "id": "bb268aab-d843-4402-94e0-bf34e4102b81",
  "content": "// ============ 角色卡对应世界书和聊天世界书自动捆绑解绑 ============\nconst delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\nconst toSortedJson = (iterable) => JSON.stringify([...iterable].sort());\n\nconst SCRIPT_VAR = { type: \"script\" };\n\n// 初始化脚本变量（已存在则不覆盖）\ninsertVariables(\n  { joezhangynLastBindState: { Char_Worldbooks: [], Chat_Worldbook: null } },\n  SCRIPT_VAR,\n);\n\nlet lastChatChangeTimestamp = 0;\n\n// 检查并删除空世界书（无条目，或所有条目内容均为空）\nasync function checkAndDeleteEmptyWorldbook(worldbookName) {\n  if (!worldbookName) return;\n  try {\n    const entries = await getWorldbook(worldbookName);\n    if (!entries) return;\n\n    const isEmpty =\n      entries.length === 0 ||\n      entries.every((e) => !e.content?.trim());\n\n    if (isEmpty) {\n      await deleteWorldbook(worldbookName);\n      console.log(`[自动清理] 删除空世界书: ${worldbookName}`);\n    }\n  } catch (err) {\n    // 世界书不存在或读取失败，忽略\n  }\n}\n\n// 标准化世界书名为 Set 集合\nfunction normalizeWorldbookNames(bookData) {\n  const set = new Set();\n  if (!bookData) return set;\n\n  if (typeof bookData === \"string\") {\n    set.add(bookData);\n  } else if (Array.isArray(bookData)) {\n    bookData.forEach((book) => book && set.add(book));\n  } else {\n    if (bookData.primary) set.add(bookData.primary);\n    if (Array.isArray(bookData.additional)) {\n      bookData.additional.forEach((book) => book && set.add(book));\n    }\n  }\n  return set;\n}\n\n// 批量清理所有空的 Chat_Book_* 世界书（跳过当前聊天的世界书）\nasync function cleanupEmptyChatWorldbooks() {\n  try {\n    const allBooks = getWorldbookNames();\n    const currentChatBook = getChatWorldbookName(\"current\");\n    const chatBooks = allBooks.filter(\n      (name) => name.startsWith(\"Chat_Book_\") && name !== currentChatBook,\n    );\n\n    for (const bookName of chatBooks) {\n      await checkAndDeleteEmptyWorldbook(bookName);\n    }\n  } catch (err) {\n    console.error(\"[世界书管理] 批量清理聊天世界书失败:\", err);\n  }\n}\n\n// 更新全局世界书设置\nasync function updateGlobalWorldbookSettings(\n  newSelections,\n  variableData = null,\n) {\n  try {\n    const updatePromises = [rebindGlobalWorldbooks(newSelections)];\n\n    if (variableData) {\n      updatePromises.push(\n        insertOrAssignVariables({ joezhangynLastBindState: variableData }, SCRIPT_VAR),\n      );\n    }\n\n    const results = await Promise.allSettled(updatePromises);\n    const failures = results.filter((r) => r.status === \"rejected\");\n\n    if (failures.length > 0) {\n      for (const f of failures) {\n        const msg = f.reason?.message || \"\";\n        if (msg.includes(\"未找到\")) {\n          console.warn(\"[世界书管理] 检测到不存在的世界书，已自动跳过。\");\n        } else {\n          console.error(\"[世界书管理] 部分操作失败:\", f.reason);\n        }\n      }\n    }\n\n    console.log(\n      `[世界书管理] 设置已更新。当前启用: ${newSelections.length} 本`,\n    );\n    return failures.length === 0;\n  } catch (error) {\n    console.error(\"[世界书管理] 更新设置失败:\", error);\n    return false;\n  }\n}\n\n/**\n * 检查并自动导入内嵌世界书（仅首次导入，不覆盖已有世界书）\n */\nasync function importEmbeddedWorldbookIfNeeded() {\n  try {\n    const charData = getCharData(\"current\");\n    if (!charData) return null;\n\n    const char = new RawCharacter(charData);\n    const book = char.getCharacterBook();\n    if (!book?.name) return null;\n\n    const allInstalledBooks = getWorldbookNames();\n    if (allInstalledBooks.includes(book.name)) return book.name;\n\n    console.log(`[世界书管理] 发现内嵌世界书 \"${book.name}\"，正在导入...`);\n\n    try {\n      const entries = (book.entries || []).map((e) => ({\n        name: e.comment || \"\",\n        enabled: e.enabled ?? true,\n        content: e.content || \"\",\n        strategy: {\n          type: e.constant ? \"constant\" : \"selective\",\n          keys: e.keys || [],\n          keys_secondary: {\n            logic: \"and_any\",\n            keys: e.secondary_keys || [],\n          },\n        },\n        position: {\n          order: e.insertion_order ?? 100,\n        },\n      }));\n\n      await createWorldbook(book.name, entries);\n\n      console.log(\n        `[世界书管理] \"${book.name}\" 导入成功，共 ${entries.length} 条`,\n      );\n      return book.name;\n    } catch (importError) {\n      console.error(`[世界书管理] 导入 \"${book.name}\" 出错:`, importError);\n      try {\n        await deleteWorldbook(book.name);\n      } catch (e) {}\n      return null;\n    }\n  } catch (error) {\n    console.error(\"[世界书管理] 自动导入内嵌书失败:\", error);\n  }\n  return null;\n}\n\n// 核心逻辑执行函数\nasync function executeBindingLogic() {\n  try {\n    const embeddedBookName = await importEmbeddedWorldbookIfNeeded();\n\n    const [global_worldbooks, char_worldbooks, chat_worldbook, scriptVars] =\n      await Promise.all([\n        getGlobalWorldbookNames(),\n        getCharWorldbookNames(\"current\"),\n        getOrCreateChatWorldbook(\"current\"),\n        getVariables(SCRIPT_VAR),\n      ]);\n\n    const currentGlobalSelection = new Set(global_worldbooks || []);\n    const originalSelectionJson = toSortedJson(currentGlobalSelection);\n\n    const lastState = scriptVars?.joezhangynLastBindState || {};\n    const lastCharBooks = normalizeWorldbookNames(lastState.Char_Worldbooks);\n    const lastChatBook = lastState.Chat_Worldbook;\n\n    const currentUserCharBooks = normalizeWorldbookNames(char_worldbooks);\n    if (embeddedBookName) {\n      currentUserCharBooks.add(embeddedBookName);\n    }\n\n    for (const book of lastCharBooks) currentGlobalSelection.delete(book);\n\n    if (lastChatBook) {\n      currentGlobalSelection.delete(lastChatBook);\n      if (lastChatBook !== chat_worldbook)\n        checkAndDeleteEmptyWorldbook(lastChatBook);\n    }\n\n    for (const book of currentUserCharBooks) currentGlobalSelection.add(book);\n    if (chat_worldbook) currentGlobalSelection.add(chat_worldbook);\n\n    const newSelectionArray = Array.from(currentGlobalSelection);\n    const newSelectionJson = toSortedJson(newSelectionArray);\n\n    const variableData = {\n      Char_Worldbooks: Array.from(currentUserCharBooks),\n      Chat_Worldbook: chat_worldbook,\n    };\n\n    if (originalSelectionJson !== newSelectionJson) {\n      console.log(\"[世界书管理] 状态变更，正在同步...\");\n      await updateGlobalWorldbookSettings(newSelectionArray, variableData);\n    } else {\n      const lastVariableJson = JSON.stringify(lastState.Char_Worldbooks);\n      const currentVariableJson = JSON.stringify(variableData.Char_Worldbooks);\n\n      if (\n        lastVariableJson !== currentVariableJson ||\n        lastChatBook !== chat_worldbook\n      ) {\n        await insertOrAssignVariables(\n          { joezhangynLastBindState: variableData },\n          SCRIPT_VAR,\n        );\n      }\n    }\n  } catch (error) {\n    console.error(\"[世界书管理] 绑定逻辑错误:\", error);\n  }\n}\n\n// 主函数: 带并发锁的防抖执行\nasync function BindUnBindGlobalWorldbook() {\n  const thisTimestamp = Date.now();\n  lastChatChangeTimestamp = thisTimestamp;\n  const isObsolete = () => lastChatChangeTimestamp !== thisTimestamp;\n\n  const delays = [300, 900, 1300];\n  for (const ms of delays) {\n    await delay(ms);\n    if (isObsolete()) return;\n    await executeBindingLogic();\n  }\n\n  if (!isObsolete()) {\n    await cleanupEmptyChatWorldbooks();\n  }\n}\n\n// 角色删除清理\nasync function UnBindGlobalWorldbookDelete() {\n  const thisTimestamp = Date.now();\n  lastChatChangeTimestamp = thisTimestamp;\n\n  try {\n    const [global_worldbooks, scriptVars] = await Promise.all([\n      getGlobalWorldbookNames(),\n      getVariables(SCRIPT_VAR),\n    ]);\n\n    const selectedWorldbooksSet = new Set(global_worldbooks || []);\n    const lastState = scriptVars?.joezhangynLastBindState || {};\n    const lastCharBooks = normalizeWorldbookNames(lastState.Char_Worldbooks);\n    const lastChatBook = lastState.Chat_Worldbook;\n\n    for (const book of lastCharBooks) {\n      selectedWorldbooksSet.delete(book);\n      checkAndDeleteEmptyWorldbook(book);\n    }\n\n    if (lastChatBook) {\n      selectedWorldbooksSet.delete(lastChatBook);\n      checkAndDeleteEmptyWorldbook(lastChatBook);\n    }\n\n    await updateGlobalWorldbookSettings(Array.from(selectedWorldbooksSet));\n    console.log(\"[世界书管理] 已清理删除角色的相关绑定\");\n  } catch (error) {\n    console.error(\"[世界书管理] 删除清理失败:\", error);\n  }\n\n  await cleanupEmptyChatWorldbooks();\n}\n\n// 注册事件\neventOn(tavern_events.CHAT_CHANGED, BindUnBindGlobalWorldbook);\neventOn(tavern_events.CHARACTER_DELETED, UnBindGlobalWorldbookDelete);",
  "info": "# 作者：JoeZhangYN\n## 版本日期: 2026/1/31\n## 功能\n\n1. **自动绑定/解绑世界书** — 切换角色卡时，自动从全局世界书中移除上一个角色的世界书，启用当前角色的世界书和聊天世界书                                                                                                                                  \n2. **自动导入内嵌世界书** — 首次切换到角色卡时，检测内嵌世界书（character book），若未安装则自动创建并导入条目，已存在则跳过不覆盖\n3. **删除角色自动清理** — 删除角色卡时，自动从全局列表中移除该角色的世界书和聊天世界书\n4. **空世界书自动清理** — 清理所有条目内容为空的 `Chat_Book_*` 聊天世界书，避免残留堆积\n5. **防抖并发控制** — 时间戳锁 + 三轮延时执行，防止快速切换角色卡时重复触发\n\n## 变量说明\n\n- `joezhangynLastBindState` — 上次记录的世界书绑定信息\n- `Char_Worldbooks` — 记录当前角色卡世界书，切换时移除\n- `Chat_Worldbook` — 记录当前聊天世界书，切换时移除\n\n### 更新日志\n\n- **25/5/5** 删除角色卡时自动移除和删除空聊天世界书（在删除角色卡时发现聊天世界书残留堆积）\n- **25/5/6** 新增如果遇到不存在世界书的判断处理（比如角色卡未导入世界书，也不影响原有功能）\n- **25/11/20**\n  1. 修复核心错误与 API 迁移\n  2. 解决\"时序竞态\"问题（挂载失败）\n  3. 新增\"全自动导入\"功能\n  4. 性能与并发优化（防抖锁）\n  5. 算法效率优化\n- **26/1/31**\n  1. 变量作用域从全局（`global`）迁移到脚本（`script`），避免污染全局变量\n  2. 新增 `insertVariables` 安全初始化\n  3. 替换未文档化内部 API，改用标准 API `createWorldbook(name, entries)` 一次调用完成导入\n  4. `Promise.all` 改为 `Promise.allSettled`，绑定失败不阻断变量更新\n  5. 空世界书判定增强：所有条目内容为空即视为空世界书\n  6. 删除角色时同时清理 `Chat_Worldbook`，新增 `cleanupEmptyChatWorldbooks` 批量清理",
  "button": {
    "enabled": true,
    "buttons": []
  },
  "data": {}
}